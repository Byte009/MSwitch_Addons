#NAME MSwitch_Seasons
#HELP Stellt die Readings month, weekday und season bereit. Aktualisierung erfolgt immer um 00:01 Uhr oder manuell\n Achtung: fuer volle Funkzionalitaet muss das Device MSwitch_Config heissen !
#V 3.22
#VS V2.01
#S status -> settings_nicht_anwenden
#S MSwitch_Language -> DE
#S .Trigger_cmd_on -> no_trigger
#S .Device_Affected_Details -> FreeCmd-AbsCmd1#[NF]undefined#[NF]cmd#[NF]{;;my %attrs = (;;"disable"  => "0",;;"MSwitch_Language"  => "DE",;;"MSwitch_Comments"  => "0",;;"MSwitch_Read_Log"  => "0",;;"MSwitch_Help"  => "1",;;"MSwitch_Debug"  => "1",;;"MSwitch_Expert"  => "0",;;"MSwitch_Delete_Delays"  => "1",;;"MSwitch_Include_Devicecmds"  => "1",;;"MSwitch_Modul_Mode"  => "0",;;"MSwitch_generate_Events"  => "0",;;"MSwitch_Include_Webcmds"  => "0",;;"MSwitch_Include_MSwitchcmds"    => "0",;;"MSwitch_Lock_Quickedit"  => "1",;;"MSwitch_Ignore_Types"  => "notify allowed at watchdog doif fhem2fhem telnet FileLog readingsGroup FHEMWEB autocreate eventtypes readingsproxy svg cul",;;"MSwitch_Trigger_Filter"  => "",;;"MSwitch_Extensions"  => "0",;;"MSwitch_DeleteCMDs"  => "automatic",;;"MSwitch_Mode"  => "Notify",;;"MSwitch_Condition_Time"  => "0",;;"MSwitch_Selftrigger_always"  => "0",;;"MSwitch_Safemode"  => "1",;;"MSwitch_Startdelay"  => "10",;;"MSwitch_Eventhistory"  => "10",;;"MSwitch_Device_Groups"  => "";;);;;;;for my $key ( keys %attrs ){;;      fhem("set $SELF $key $attrs{$key}");;;    };;;;fhem("set $SELF refresh 1");;;}#[NF]{;;my %attrs = (;;"disable"  => "0",;;"MSwitch_Language"  => "DE",;;"MSwitch_Comments"  => "0",;;"MSwitch_Read_Log"  => "0",;;"MSwitch_Help"  => "1",;;"MSwitch_Debug"  => "1",;;"MSwitch_Expert"  => "0",;;"MSwitch_Delete_Delays"  => "1",;;"MSwitch_Include_Devicecmds"  => "1",;;"MSwitch_Modul_Mode"  => "0",;;"MSwitch_generate_Events"  => "0",;;"MSwitch_Include_Webcmds"  => "0",;;"MSwitch_Include_MSwitchcmds"    => "0",;;"MSwitch_Lock_Quickedit"  => "1",;;"MSwitch_Ignore_Types"  => "notify allowed at watchdog doif fhem2fhem telnet FileLog readingsGroup FHEMWEB autocreate eventtypes readingsproxy svg cul",;;"MSwitch_Trigger_Filter"  => "",;;"MSwitch_Extensions"  => "0",;;"MSwitch_DeleteCMDs"  => "automatic",;;"MSwitch_Mode"  => "Notify",;;"MSwitch_Condition_Time"  => "0",;;"MSwitch_Selftrigger_always"  => "0",;;"MSwitch_Safemode"  => "1",;;"MSwitch_Startdelay"  => "",;;"MSwitch_Eventhistory"  => "",;;"MSwitch_Device_Groups"  => "";;);;;for my $key ( keys %attrs ){;;      fhem("set $SELF $key deleted");;;    };;$data{MSwitch}{Showinfo}{$SELF} = "Alle Voreinstelliungen wurden geloescht";;;fhem("deletereading $SELF MSwitch_.*");;;fhem("deletereading $SELF disable");;;fhem("set $SELF refresh 1");;;}#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]FreeCmd-AbsCmd2#[NF]undefined#[NF]cmd#[NF]{;;fhem("set $SELF exec_cmd_2 ID 1");;;my $target = "[$SELF:Anwenden_auf]";;;Log3("test",0,$target);;;    foreach my $attrdevice ( keys %{$attr{$target}})   ;;    {;;        Log3("test",0,$attrdevice );;;        next if ( $attrdevice !~ m/(^MSwitch_.*#[SR]^disabled.*)/ );;;;;        fhem("set $SELF $attrdevice ".$attr{$target}{$attrdevice});;;    };;fhem("set $SELF refresh 1");;;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]2#[NF]#[NF]0#[NF]0#[NF]1#[NF]1
#S .Trigger_off -> no_trigger
#S .Trigger_time -> 
#S .Trigger_cmd_off -> no_trigger
#S last_cmd -> 1
#S MSwitch_Include_MSwitchcmds -> 0
#S MSwitch_Expert -> 1
#S MSwitch_Safemode -> 1
#S MSwitch_Help -> 0
#S refresh -> 0
#S Sys_Extension -> on
#S MSwitch_Include_Webcmds -> 0
#S .sysconf -> "'
#S MSwitch_Extensions -> 0
#S MSwitch_Mode -> Full
#S MSwitch_DeleteCMDs -> automatic
#S .Device_Affected -> FreeCmd-AbsCmd1,FreeCmd-AbsCmd2
#S .Distributor -> .*=>cmd1 ID 1#[nl]
#S MSwitch_Ignore_Types -> notify allowed at watchdog doif fhem2fhem telnet FileLog readingsGroup FHEMWEB autocreate eventtypes readingsproxy svg cul
#S MSwitch_Debug -> 0
#S .First_init -> done
#S .V_Check -> V2.01
#S state -> off
#S .Device_Events -> no_trigger
#S MSwitch_Lock_Quickedit -> 1
#S MSwitch_Delete_Delays -> 1
#S .Trigger_condition -> "$EVENT"#[sp]=#[ti]#[sp]m/(.*?)DEFINED.*/
#S Trigger_device -> no_trigger
#S Anwenden_auf -> All_Off_Dev
#S MSwitch_Include_Devicecmds -> 1
#S .Trigger_on -> no_trigger
#S Trigger_log -> on
#A webCmd -> Anwenden_auf:Sets_laden:Grundeinstellung_Laden:Löschen:status
#A setList -> refresh status:settings_anwenden,settings_nicht_anwenden disable:0,1 MSwitch_Language:EN,DE MSwitch_Comments:0,1 MSwitch_Read_Log:0,1 MSwitch_Help:0,1 MSwitch_Debug:0,1,2,3,4 MSwitch_Expert:0,1 MSwitch_Delete_Delays:0,1 MSwitch_Include_Devicecmds:0,1 MSwitch_Modul_Mode:0,1 MSwitch_generate_Events:0,1 MSwitch_Include_Webcmds:0,1 MSwitch_Include_MSwitchcmds:0,1 MSwitch_Lock_Quickedit:0,1 MSwitch_Ignore_Types:textField-long MSwitch_Trigger_Filter MSwitch_Extensions:0,1 MSwitch_DeleteCMDs:manually,automatic,nosave MSwitch_Mode:Full,Notify,Toggle,Dummy MSwitch_Condition_Time:0,1 MSwitch_Selftrigger_always:0,1 MSwitch_Safemode:0,1 MSwitch_Startdelay:0,10,20,30,60,90,120 MSwitch_Eventhistory:0,1,2,3,4,5,10,20,30,40,50,60,70,80,90,100,150,200 MSwitch_Device_Groups:textField-long
#A MSwitch_Modul_Mode -> 1
#A MSwitch_Safemode -> 1
#A MSwitch_Debug -> 0
#A MSwitch_Selftrigger_always -> 0
#A eventMap -> /exec_cmd_1 ID 1:Grundeinstellung_Laden/exec_cmd_2 ID 1:Löschen/exec_cmd_1 ID 2:Sets_laden/
#A MSwitch_Eventhistory -> 0
#A MSwitch_Help -> 0
#A MSwitch_setList -> Anwenden_auf:[TYPE=MSwitch]
#A MSwitch_Language -> DE
#A icon -> system_fhem
#A MSwitch_Mode -> Full
#A MSwitch_generate_Events -> 0
#A MSwitch_DeleteCMDs -> automatic
#A MSwitch_Ignore_Types -> "TYPE=Global"
#A MSwitch_Expert -> 1
#A verbose -> 0
#A readingList -> status disable MSwitch_Language MSwitch_Comments MSwitch_Read_Log MSwitch_Help MSwitch_Debug MSwitch_Expert MSwitch_Delete_Delays MSwitch_Include_Devicecmds MSwitch_Modul_Mode MSwitch_generate_Events MSwitch_Include_Webcmds MSwitch_Include_MSwitchcmds MSwitch_Lock_Quickedit MSwitch_Ignore_Types MSwitch_Trigger_Filter MSwitch_Extensions MSwitch_DeleteCMDs MSwitch_Mode MSwitch_Condition_Time MSwitch_Selftrigger_always MSwitch_Safemode MSwitch_Startdelay MSwitch_Eventhistory MSwitch_Device_Groups refresh




#NAME MSwitch_Seasons
#HELP Stellt die Readings month, weekday und season bereit. Aktualisierung erfolgt immer um 00:01 Uhr oder manuell
#V 3.17
#VS V2.01
#S EVTPART3 -> 00:01
#S last_activation_by -> timer
#S weekday -> please_update
#S EVTFULL -> Seasons:execute_timer_P3:00:01
#S season -> please_update
#S Trigger_log -> off
#S EVENT -> Seasons:execute_timer_P3:00:01
#S EVTPART2 -> execute_timer_P3
#S .Device_Affected_Details -> FreeCmd-AbsCmd1#[NF]undefined#[NF]cmd#[NF]{;;my $sec;;;my $min;;;my $hour;;;my $mday;;;my $mon;;;my $year;;;my $wday;;;my $yday;;;my $isdst;;;;;my @monat = qw(Januar Februar März April Mai Juni Jul August Septem Oktober November Dezember);;;;;($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);;;$mon ++;;;;;#Log3("test",0,"$mon - $mday");;;;;if (($mon == 3 && $mday >= 20) or $mon == 4 or $mon == 5 or ($mon == 6 and $mday < 21)){fhem("set $SELF season Fruehling");};;;if (($mon == 6 and $mday >= 21) or $mon == 7 or $mon == 8 or ($mon == 8 and $mday < 22)){fhem("set $SELF season Sommer");};;;if (($mon == 9 and $mday >= 1) or $mon == 10 or $mon == 11 or ($mon == 12 && $mday < 22)){fhem("set $SELF season Herbst");};;;if (($mon == 12 and $mday >= 22) or $mon == 1 or $mon == 2 or ( $mon == 3 && $mday < 20)){fhem("set $SELF season Winter");};;;fhem("set $SELF weekday ".qw(Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag)[strftime('%w', localtime)]);;;$mon=$mon-1;;;fhem("set $SELF month ".$monat[$mon]);;;;;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]undefined#[NF]undefined#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]1#[NF]0
#S .Trigger_cmd_on -> no_trigger
#S .Device_Events -> no_trigger
#S .Device_Affected -> FreeCmd-AbsCmd1
#S EVTPART1 -> Seasons
#S .Trigger_on -> no_trigger
#S .First_init -> done
#S month -> please_update
#S .Trigger_time -> on~off~ononly[00#[dp]01]~offonly~onoffonly
#S .Trigger_cmd_off -> no_trigger
#S state -> active
#S .V_Check -> V2.01
#S .Trigger_off -> no_trigger
#S Trigger_device -> no_trigger
#A MSwitch_Mode -> Notify
#A eventMap -> /exec_cmd_1:update/
#A MSwitch_Lock_Quickedit -> 1
#A MSwitch_Expert -> 0
#A MSwitch_Ignore_Types -> .*
#A MSwitch_Include_Webcmds -> 0
#A MSwitch_Safemode -> 1
#A MSwitch_Delete_Delays -> 0
#A MSwitch_Extensions -> 0
#A MSwitch_Include_Devicecmds -> 1
#A webCmd -> update
#A readingList -> season weekday month
#A setList -> season:Winter,Fruehling,Sommer,Herbst weekday month
#A disable -> 0
#A MSwitch_Help -> 0
#A MSwitch_Include_MSwitchcmds -> 0
#A MSwitch_generate_Events -> 0
#A MSwitch_DeleteCMDs -> manually
#A MSwitch_Modul_Mode -> 1
#A MSwitch_Eventhistory -> 0
#A MSwitch_Debug -> 0
#A stateFormat -> Jahreszeit: season -#[nl]Wochentag: weekday -#[nl]Monat: month#[nl]


#-NEXT-

#NAME MSwitch_Updater
#HELP Testet auf MSwitch Updates . Je nach Einstellung wird diese Information per Telegram versendet. Hierzu wird da erste verfuegbare Telegramdevice verwendet, wenn kein Device eingestellt ist
#V 3.14b
#VS V2.01
#S update_avaible -> no_update_avaible
#S .Device_Events -> no_trigger
#S last_cmd -> 1
#S .Trigger_time -> on~off~ononly[12#[dp]00]~offonly~onoffonly
#S Trigger_device -> no_trigger
#S .Trigger_cmd_on -> no_trigger
#S EVTFULL -> MSwitch_Updater:execute_timer_P3:12:00
#S .Trigger_cmd_off -> no_trigger
#S .V_Check -> V2.01
#S EVENT -> MSwitch_Updater:execute_timer_P3:12:00
#S aktuelle_Version -> 3.14b
#S EVTPART3 -> 12:00
#S last_activation_by -> timer
#S update_Version -> 3.14b
#S EVTPART1 -> MSwitch_Updater
#S .Trigger_off -> no_trigger
#S .Device_Affected -> FreeCmd-AbsCmd1,FreeCmd-AbsCmd2,FreeCmd-AbsCmd3,FreeCmd-AbsCmd4,FreeCmd-AbsCmd5,MSwitch_Self-AbsCmd1
#S state -> no_update_avaible
#S send_info -> off
#S Trigger_log -> off
#S EVTPART2 -> execute_timer_P3
#S .First_init -> done
#S update_info -> Change: bugfix frontend
#S .Device_Affected_Details -> FreeCmd-AbsCmd1#[NF]undefined#[NF]cmd#[NF]{;;my $updateinfo="";;;my $updatelink= $data{MSwitch}{udateinfolink};;;$updateinfo = get($data{MSwitch}{udateinfolink});;;;;;;Log3( 'test', 0, $updateinfo );;;;;;;$updateinfo  =~ s/\n/NEWLINE/g;;;;;my @uinfos = split( /NEWLINE/, $updateinfo );;;;;Log3( 'test', 0, @uinfos."@uinfos" );;;fhem("setreading $SELF aktuelle_Version $data{MSwitch}{version}");;;fhem("setreading $SELF update_Version $uinfos[1]");;;if ($uinfos[1] ne $data{MSwitch}{version}){;;;;fhem("setreading $SELF update_avaible update_avaible");;;fhem("setreading $SELF state update_avaible");;;}else{;;fhem("setreading $SELF update_avaible no_update_avaible");;;fhem("setreading $SELF state no_update_avaible");;;};;;;;;fhem("setreading $SELF update_info $uinfos[2]");;;};;;;#[NF]#[NF]delay1#[NF]delay1#[NF]0#[NF]0#[NF]#[NF]#[NF]undefined#[NF]undefined#[NF]1#[NF]0#[NF]check for updates#[NF]0#[NF]0#[NF]1#[NF]0#[ND]FreeCmd-AbsCmd2#[NF]undefined#[NF]cmd#[NF]{;;my @devices = devspec2array('TYPE=TelegramBot');;;if (@devices > 0);;{;;fhem("set $SELF Telebot $devices[0]");;;};;else;;{;;fhem("set $SELF Telebot no bot found");;;};;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF][$SELF:send_info] eq "on" AND [AttrVal:$SELF:Telebot:nobot] eq "nobot"#[NF]#[NF]0#[NF]0#[NF]2#[NF]0#[NF]search telegrambot sucht den ersten verf�gbaren bot zm senden.#[NF]0#[NF]0#[NF]1#[NF]0#[ND]FreeCmd-AbsCmd3#[NF]undefined#[NF]cmd#[NF]set [$SELF:Telebot] _msg MSwitchupdate auf Version [$SELF:update_Version] verfuegbar.\n[$SELF:update_info];;;;#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:01#[NF]00:00:00#[NF][$SELF:send_info] eq "on" and ([$SELF:aktuelle_Version] ne [$SELF:update_Version])#[NF]#[NF]0#[NF]0#[NF]3#[NF]0#[NF]send message #[NF]0#[NF]0#[NF]1#[NF]0#[ND]FreeCmd-AbsCmd4#[NF]undefined#[NF]cmd#[NF]update all https://raw.githubusercontent.com/Byte009/FHEM-MSwitch/master/controls_mswitch.txt;#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[ND]FreeCmd-AbsCmd5#[NF]undefined#[NF]cmd#[NF]reload 98_MSwitch.pm;#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:05#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]2#[NF]1#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[ND]MSwitch_Self-AbsCmd1#[NF]exec_cmd_1#[NF]no_action#[NF]#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:03#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]3#[NF]1#[NF]#[NF]0#[NF]0#[NF]1#[NF]0
#S .Trigger_on -> no_trigger
#S .sortby -> priority
#A MSwitch_Ignore_Types -> .*
#A readingList -> aktuelle_Version update_Version update_avaible update_info Telebot send_info state
#A devStateIcon -> no_update_avaible:security@green:check_Updates update_avaible:security@red:check_Updates
#A MSwitch_Comments -> 1
#A MSwitch_Help -> 1
#A MSwitch_Modul_Mode -> 1
#A setList -> send_info:on,off Telebot
#A MSwitch_Delete_Delays -> 1
#A icon -> system_fhem
#A webCmd -> send_info:check_Updates:make_Updates
#A MSwitch_Mode -> Notify
#A MSwitch_Debug -> 1
#A MSwitch_DeleteCMDs -> nosave
#A MSwitch_Extensions -> 0
#A MSwitch_Lock_Quickedit -> 1
#A webCmdLabel -> send updateinfo: : :
#A MSwitch_Include_Devicecmds -> 1
#A room -> MSwitch
#A MSwitch_Expert -> 1
#A MSwitch_Safemode -> 1
#A MSwitch_Eventhistory -> 0
#A MSwitch_Include_Webcmds -> 0
#A eventMap -> /exec_cmd_1:check_Updates/exec_cmd_1 ID 1:make_Updates/
#A MSwitch_Include_MSwitchcmds -> 0

#-NEXT-

#NAME Kamineffekt
#HELP Kamin und Feuerwerkseffekt fuer alle HueDevices. Zieldevice muss nur ueber entsprechendes Attribut eingestellt werden.
#V 3.11
#VS V2.01
#S effect -> Kamin
#S .Trigger_on -> .*effect.*
#S EVTPART3 -> off
#S EVTPART1 -> Kamin
#S state -> off
#S last_event -> MSwitch_Self:off:
#S .Trigger_cmd_on -> no_trigger
#S Trigger_log -> off
#S .Trigger_cmd_off -> no_trigger
#S .info -> Zum setzten des angesprochenen Devices ist nur das Attribut Devices anzupassen. Mehrere Devices sind durch Komma zu trennen.
#S EVTPART2 -> MSwitch_Self
#S .Device_Affected -> FreeCmd-AbsCmd1,FreeCmd-AbsCmd2,FreeCmd-AbsCmd3,MSwitch_Self-AbsCmd1
#S Trigger_device -> no_trigger
#S huecomand -> set HUEDevice1 hue 5892 : bri 48 : transitiontime 1 immediateUpdate:noUpdate
#S .Trigger_off -> no_trigger
#S EVENT -> MSwitch_Self:off:
#S last_activation_by -> event
#S .Device_Affected_Details -> FreeCmd-AbsCmd1#[NF]undefined#[NF]cmd#[NF]{;;;;my $test =AttrVal( "$SELF", "Devices", "" );;;my @bulbs=split(/ /,$test);;;;;  foreach (@bulbs) {;;;;    my $bulb=$_;;;;;    my $hue = int((rand()*3460)+5460);;;    my $sat = int(rand(64)+170);;;    my $bri = int(rand(60)+16);;;    my $delay = (rand()+0.1);;;    my $transitiontime = int($delay * 10);;;;;fhem("set $SELF delay $delay");;;fhem("set $SELF huecomand set $bulb hue $hue : bri $bri : transitiontime 1 immediateUpdate:noUpdate");;;fhem("set $bulb hue $hue : bri $bri : transitiontime 1 immediateUpdate:noUpdate");;;;;fhem("set $bulb hue $hue : bri 0 : transitiontime $transitiontime immediateUpdate:noUpdate");;;;;;;#fhem("set $bulb rgb 000000 : transitiontime $transitiontime");;;};;}#[NF]#[NF]delay1#[NF]delay1#[NF]0#[NF]0#[NF][$SELF:effect] eq "Kamin"#[NF]#[NF]undefined#[NF]undefined#[NF]1#[NF]0#[NF]Effekt Kamin#[NF]0#[NF]0#[NF]1#[NF]1#[ND]FreeCmd-AbsCmd2#[NF]undefined#[NF]cmd#[NF]{;;  my $test =AttrVal( "$SELF", "Devices", "" );;;  my @bulbs=split(/ /,$test);;;  foreach (@bulbs) {;;;;    my $bulb=$_;;;;;    my $hue = int((rand(65534))+1);;;    my $bri = int(rand(224)+30);;;    my $transitiontime = int((rand(30))+1);;;    my $delay = int(($transitiontime / 10)+1);;;;;fhem("set $SELF delay $delay");;;fhem("set $SELF hueomand set $bulb hue $hue : bri $bri : transitiontime 1 immediateUpdate:noUpdate");;;fhem("set $bulb hue $hue : bri $bri : transitiontime 1 immediateUpdate:noUpdate");;;;;fhem("set $bulb hue $hue : bri 0 : transitiontime $transitiontime immediateUpdate:noUpdate");;;;;;;#fhem("set $bulb rgb 000000 : transitiontime $transitiontime");;;};;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF][$SELF:effect] eq "Feuerwerk"#[NF]#[NF]undefined#[NF]undefined#[NF]1#[NF]0#[NF]Effekt Feuerwerk#[NF]0#[NF]0#[NF]1#[NF]1#[ND]FreeCmd-AbsCmd3#[NF]undefined#[NF]cmd#[NF]#[NF]{;;  my $test =AttrVal( "$SELF", "Devices", "" );;;  my @bulbs=split(/ /,$test);;;  foreach (@bulbs) ;;{;;my $bulb=$_;;;fhem("set $bulb off");;;};;}#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]undefined#[NF]undefined#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]MSwitch_Self-AbsCmd1#[NF]exec_cmd_1#[NF]del_delays#[NF]#[NF]#[NF]delay1#[NF]delay1#[NF][$SELF:delay]#[NF]00:00:00#[NF]#[NF]#[NF]undefined#[NF]undefined#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]1#[NF]1
#S .First_init -> done
#S EVTFULL -> Kamin:MSwitch_Self:off
#S .Device_Events -> no_trigger .*effect.*
#S delay -> 1.07540710849622
#S .V_Check -> V2.01
#A setList -> delay effect:Kamin,Feuerwerk huecomand on off
#A MSwitch_Ignore_Types -> notify allowed at watchdog doif fhem2fhem telnet FileLog readingsGroup FHEMWEB autocreate eventtypes readingsproxy svg cul
#A MSwitch_Mode -> Full
#A MSwitch_Delete_Delays -> 1
#A MSwitch_Debug -> 0
#A MSwitch_Eventhistory -> 0
#A MSwitch_Comments -> 1
#A userattr -> Devices
#A readingList -> delay effect huecomand
#A Devices -> HUEDevice1
#A MSwitch_Expert -> 0
#A MSwitch_Lock_Quickedit -> 1
#A MSwitch_Selftrigger_always -> 1
#A MSwitch_Safemode -> 0
#A stateFormat -> state
#A MSwitch_generate_Events -> 0
#A MSwitch_Include_Devicecmds -> 1
#A MSwitch_Help -> 0
#A webCmd -> on:off:effect
#A MSwitch_Extensions -> 0
#A MSwitch_Include_MSwitchcmds -> 0
#A MSwitch_Include_Webcmds -> 0

#-NEXT-

#NAME AlexaMaxVolume
#HELP Begrenzt die Lautstaerke von Amazon Echos<br>Zeiten und maximale Lautstaerke ist einstellbar.
#V 3.0
#VS V2.01
#S last_cmd -> 2
#S time1 -> 20:00
#S .First_init -> done
#S .sortby -> priority
#S .V_Check -> V2.00
#S time2 -> 06:00
#S .Device_Affected_Details -> FreeCmd-AbsCmd1#[NF]undefined#[NF]cmd#[NF]set $EVTPART1 speak [$SELF:speak];;;#[NF]get $EVTPART1 settings#[NF]delay0#[NF]delay1#[NF]00:00:03#[NF]00:00:00#[NF][[ReadingsVal:$SELF:time1:0]-[ReadingsVal:$SELF:time2:0]] AND $EVTPART3 > [ReadingsVal:$SELF:volume:0] #[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]FreeCmd-AbsCmd2#[NF]undefined#[NF]cmd#[NF]set $EVTPART1 volume [$SELF:volume];#[NF]get $EVTPART1 settings#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF][[ReadingsVal:$SELF:time1:0]-[ReadingsVal:$SELF:time2:0]] AND $EVTPART3 > [ReadingsVal:$SELF:volume:0]  #[NF]#[NF]0#[NF]0#[NF]2#[NF]0#[NF]#[NF]0#[NF]0#[NF]1#[NF]1
#S EVTPART3 -> 100
#S .Trigger_Whitelist -> TYPE=echodevice
#S speak -> Lautstaerke wurde an Maximallautstaerke angepasst
#S EVTPART1 -> ECHO_G2A0P30774320Q50
#S .Trigger_condition -> "$EVENT"#[sp]=#[ti]#[sp]m/(#[pt]*)(lautst.*rke|volume|lauter)(#[pt]*)/#[sp]AND#[sp][$SELF#[dp]status]#[sp]eq#[sp]"an"
#S status -> aus
#S last_event -> volume_alarm:100
#S EVTFULL -> ECHO_G2A0P30774320Q50:volume_alarm:100
#S EVENT -> volume_alarm:100
#S EVTPART2 -> volume_alarm
#S .Trigger_time -> 
#S .Trigger_on -> no_trigger
#S state -> active
#S last_activation_by -> event
#S .Trigger_cmd_on -> volume:.*
#S .Trigger_cmd_off -> .*lauter|.*lautst.*rke
#S .Device_Affected -> FreeCmd-AbsCmd1,FreeCmd-AbsCmd2
#S Trigger_device -> ECHO_G2A0P30774320Q50
#S Trigger_log -> off
#S .Trigger_off -> no_trigger
#S volume -> 0
#S .Device_Events -> no_trigger volume:.* .*lauter|.*lautstärke
#A readingList -> time1 time2 time3 volume speak status
#A MSwitch_Include_MSwitchcmds -> 0
#A MSwitch_Ignore_Types -> "TYPE=echodevice"
#A webCmdLabel -> von:bis:maximal   :status
#A MSwitch_Include_Devicecmds -> 1
#A MSwitch_Lock_Quickedit -> 1
#A MSwitch_Mode -> Notify
#A webCmd -> time1:time2:volume:status
#A MSwitch_Extensions -> 0
#A MSwitch_Expert -> 1
#A disable -> 0
#A setList -> time1:time time2:time volume:slider,0,1,100 speak status:an,aus
#A MSwitch_Include_Webcmds -> 0
#A MSwitch_Help -> 0
#A MSwitch_Delete_Delays -> 1
#A MSwitch_Debug -> 0

#-NEXT-

#NAME BackupCTRL
#HELP BackupCTRL<br>Startet zur vorgegebenen Zeit ein Fhembackup und loescht alle Backups aelter X Tage vom Datentraeger.
#V 3.11
#VS V2.01
#S .Trigger_off -> no_trigger
#S Trigger_device -> no_trigger
#S last_activation_by -> manual
#S .Device_Affected_Details -> FreeCmd-AbsCmd1#[NF]undefined#[NF]cmd#[NF]{;;fhem("backup");;;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]2#[NF]0#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]FreeCmd-AbsCmd2#[NF]undefined#[NF]cmd#[NF]{;;my $weg=0;;;my $entry="";;;my $verzeichnis = AttrVal( 'global', 'backupdir', './backup' );;;Log3( "$SELF", 2, "$SELF Backupverzeichniss ".$verzeichnis );;;;;my $alter =  3600 * 24 * 30; ;;opendir(DIR, $verzeichnis);;;while (my $entry = readdir(DIR)) ;; {;;  $entry = $verzeichnis.'/'.$entry;;;  Log3( "$SELF", 2, "$SELF datei ".$entry );;;  unless (-f $entry);;   {;;   next;;;   };; ;;Log3( "$SELF", 2, "$SELF entry $entry" );;;my @stat = stat($entry);;;;;$weg = 0;;;Log3( "$SELF", 2, "$SELF time ".time." dateialter ".$stat[8] );;;Log3( "$SELF", 2, "$SELF stat @stat" );;;;;if ((time - $stat[8]) > $alter) ;; { ;; unlink($entry);;; $weg = 1;;; };;;;};;closedir(DIR);;;;;if ($weg == 1);; {;; Log3( "$SELF", 2, "$SELF Es wurden Dateien geloescht die aelter als $alter Sekunden waren" );;; };;else ;; {;; Log3( "$SELF", 2, "$SELF Es wurden keine Dateien gefunden die geloescht werden muessen" );;; };;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]MSwitch_Self-AbsCmd1#[NF]off#[NF]no_action#[NF]#[NF]#[NF]delay1#[NF]delay1#[NF]00:01:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]1#[NF]1
#S EVENT -> BackupCtrl:execute_timer_P1:03:00
#S EVTPART2 -> execute_timer_P1
#S .Device_Affected -> FreeCmd-AbsCmd1,FreeCmd-AbsCmd2,MSwitch_Self-AbsCmd1
#S .V_Check -> V2.01
#S .First_init -> done
#S last_cmd -> 2
#S .Trigger_time -> on[03#[dp]00]~off~ononly~offonly
#S EVTFULL -> BackupCtrl:execute_timer_P1:03:00
#S .Device_Events -> no_trigger
#S EVTPART1 -> BackupCtrl
#S state -> off
#S EVTPART3 -> 03:00
#S .Trigger_on -> no_trigger
#S .sortby -> priority
#S Trigger_log -> off
#S .Trigger_cmd_off -> no_trigger
#S .Trigger_cmd_on -> no_trigger
#S waiting -> 1573795954.3267
#A MSwitch_Debug -> 0
#A MSwitch_Eventhistory -> 0
#A MSwitch_Ignore_Types -> notify allowed at watchdog doif fhem2fhem telnet FileLog readingsGroup FHEMWEB autocreate eventtypes readingsproxy svg cul
#A MSwitch_Mode -> Full
#A MSwitch_Delete_Delays -> 1
#A MSwitch_Extensions -> 0
#A MSwitch_Include_MSwitchcmds -> 0
#A verbose -> 2
#A MSwitch_Include_Webcmds -> 0
#A MSwitch_Include_Devicecmds -> 1
#A disable -> 0
#A MSwitch_Help -> 0
#A MSwitch_Expert -> 1
#A MSwitch_Lock_Quickedit -> 1
#A MSwitch_Safemode -> 1

#-NEXT-

#NAME Rename
#HELP Ueberwacht an MSwitch beteiligte Devices auf Namensaenderungen
#V 3.11
#VS V2.01
#S .Device_Affected -> FreeCmd-AbsCmd1
#S EVTPART2 -> RENAMED import DummyAlexa
#S EVENT -> RENAMED import DummyAlexa
#S last_activation_by -> event
#S .Device_Affected_Details -> FreeCmd-AbsCmd1#[NF]undefined#[NF]cmd#[NF]{;;my $ev = ReadingsVal( "$SELF", "incomming", "no_event" );;;my @eclude = split( / /,AttrVal( '$SELF', 'exclude_from_rename', '' ));;;my ( $cmd ,$oldorgname, $neworgname ) = split( / /, $ev );;;my @found_devices = devspec2array("TYPE=MSwitch:FILTER=.Device_Affected_Details=$oldorgname.*");;;readingsSingleUpdate( $hash, "found_devices", join("#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]undefined#[NF]undefined#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]1#[NF]1
#S Trigger_device -> global
#S .Trigger_off -> no_trigger
#S EVTFULL -> global:RENAMED import DummyAlexa
#S .Device_Events -> no_trigger .*
#S .First_init -> done
#S incomming -> SAVE
#S .V_Check -> V2.01
#S .Trigger_on -> no_trigger
#S .Trigger_condition -> "$EVENT"#[sp]=#[ti]#[sp]m/RENAMED(#[pt]*)/
#S .inc_event -> UNDEFINED Unknown CUL_TCM97001 CUL_TCM97001_Unknown
#S Sys_Extension -> on
#S .lock -> 1
#S EVTPART1 -> global
#S state -> active
#S last_event -> RENAMED import DummyAlexa
#S action -> show_only
#S .Trigger_cmd_on -> .*
#S .Trigger_cmd_off -> no_trigger
#S Exec_cmd -> set Rename_Ctrl off
#S Trigger_log -> off
#A MSwitch_Ignore_Types -> notify allowed at watchdog doif fhem2fhem telnet FileLog readingsGroup FHEMWEB autocreate eventtypes readingsproxy svg cul
#A setList -> action:show_only,change_automatic
#A MSwitch_Delete_Delays -> 1
#A MSwitch_Mode -> Notify
#A MSwitch_Debug -> 0
#A MSwitch_Eventhistory -> 0
#A MSwitch_Startdelay -> 10
#A readingList -> action
#A userattr -> exclude_from_rename
#A MSwitch_Lock_Quickedit -> 1
#A MSwitch_Expert -> 0
#A MSwitch_Safemode -> 0
#A MSwitch_Include_Devicecmds -> 1
#A disable -> 0
#A MSwitch_Help -> 0
#A MSwitch_Include_MSwitchcmds -> 0
#A webCmd -> action
#A MSwitch_Extensions -> 0
#A MSwitch_Include_Webcmds -> 0

#-NEXT-

#NAME Farbwechsler
#HELP Farbwechsler<br>Es koennen alle Geraete angesprochen werden die sich ueber set device rgb xxx steuern lassen.<br>Die Auswahl des Zieldevices erfolgt ueber ein zu setzendes Attribut.
#V 3.02 alpha
#VS V2.00
#S Trigger_device -> MSwitch_Self
#S .Device_Affected -> FreeCmd-AbsCmd1,FreeCmd-AbsCmd2,FreeCmd-AbsCmd3,FreeCmd-AbsCmd4,FreeCmd-AbsCmd5,MSwitch_Self-AbsCmd1,MSwitch_Self-AbsCmd2,MSwitch_Self-AbsCmd3,MSwitch_Self-AbsCmd4,MSwitch_Self-AbsCmd5,MSwitch_Self-AbsCmd6
#S EVENT -> last_activation_by:event
#S Time -> 00:00:05
#S .Device_Events -> (mode:Fade[bs]mode:RGB[bs]mode:Spektral[bs]rgb:.*[bs]Zeit:.*) no_trigger
#S .Trigger_condition -> 
#S .Trigger_cmd_on -> (mode:Fade|mode:RGB|mode:Spektral|rgb:.*|Zeit:.*)
#S .lock -> 1
#S EVTPART1 -> test
#S Trigger_log -> off
#S .info -> Es muessen keine Aenderungen vorgenommen werden. Das anzusprechende Device ist unter dem Attribut DeviceToSwitch einzustellen.<br>Mehrere Devices muessen durch Komma getrennt werden.<br>Die Sperre kann mit: deletereading DEVICE .lock geloescht werden.<br>Der Infotext kann mit deletereading DEVICE .info geloescht werden.
#S .Trigger_cmd_off -> mode:off
#S EVTFULL -> test:last_activation_by:event
#S changergb -> transitiontime
#S EVTPART2 -> last_activation_by
#S last_cmd -> 1
#S Zeit -> 2
#S state -> off
#S mode -> off
#S .Trigger_time -> 
#S .Trigger_off -> no_trigger
#S .Trigger_on -> no_trigger
#S last_event -> last_activation_by:event
#S .sortby -> show
#S aktrgb -> 8c577e
#S .Device_Affected_Details -> FreeCmd-AbsCmd1#[NF]undefined#[NF]cmd#[NF]{;;my $rgb;;;my ($r, $g, $b) = (int(rand(256)), int(rand(256)), int(rand(256)));;;$rgb = sprintf("%02x%02x%02x", $r, $g, $b);;;my $aktrgb = ReadingsVal( '$SELF', 'nextrgb', 'FFFFFF' );;;fhem("setreading $SELF nextrgb $rgb ");;;fhem("setreading $SELF aktrgb $aktrgb");;;my $devtoswitch = AttrVal( $name, 'DeviceToSwitch', 'no_device' );;;my $transitiontime = AttrVal( $name, 'Transitiontime', 1 );;;;;fhem("set $devtoswitch rgb $aktrgb [$SELF:Zeit]") if ('[$SELF:changergb]' eq 'timer');;;fhem("set $devtoswitch rgb $aktrgb $transitiontime") if ('[$SELF:changergb]' eq 'transitiontime');;;fhem("set $devtoswitch rgb $aktrgb") if ('[$SELF:changergb]' eq 'immediately');;;;;};;#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF][$SELF:mode] eq "Fade"#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]FreeCmd-AbsCmd2#[NF]undefined#[NF]cmd#[NF]{;;fhem("set $SELF mode Fade");;;}#[NF]{;;fhem("set $SELF wait 2");;;fhem("set $SELF del_delays");;;fhem("set $SELF mode off");;;my $devtoswitch = AttrVal( '$SELF', 'DeviceToSwitch', 'no_device' );;;fhem("set $devtoswitch off");;;fhem("deletereading $SELF todo.*");;;fhem("deletereading $SELF waiting");;;}#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]8#[NF]1#[ND]FreeCmd-AbsCmd3#[NF]undefined#[NF]cmd#[NF]{;;my $devtoswitch = AttrVal( $name, 'DeviceToSwitch', 'no_device' );;;fhem("set $devtoswitch rgb [$SELF:rgb]");;;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]4#[NF]#[NF]0#[NF]0#[NF]4#[NF]1#[ND]FreeCmd-AbsCmd4#[NF]undefined#[NF]cmd#[NF]{;;my $change = 1;;;my $rot;;;my $gruen;;;my $blau;;;my $rgb;;;my $count;;; ;;for($count=0;$count<=255;$count=$count + $change );;{;;$gruen = sprintf ("%02x", $count);;;$rgb .= sprintf "FF${gruen}00 ";;;};;for($count=255;$count>=0;$count=$count - $change );;{;;$rot = sprintf ("%02x", $count);;;$rgb .= sprintf "${rot}FF00 ";;;};;for($count=0;$count<=255;$count=$count + $change);;{;;$blau = sprintf ("%02x", $count);;;$rgb .= sprintf "00FF${blau} ";;;};;for($count=255;$count>=0;$count=$count - $change );;{;;$gruen = sprintf ("%02x", $count);;;$rgb .= sprintf "00${gruen}FF ";;;};;for($count=0;$count<=255;$count=$count + $change );;{;;$rot = sprintf ("%02x", $count);;;$rgb .= sprintf "${rot}00FF ";;;};;;;my @a = split(" ",$rgb);;;my $anz = @a;;;$anz=$anz-1;;;fhem("setreading $SELF todo $rgb");;;fhem("setreading $SELF todoanz $anz");;;fhem("setreading $SELF todofirst 1");;;fhem("set $SELF exec_cmd_1 ID 6");;;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]5#[NF]#[NF]0#[NF]0#[NF]9#[NF]1#[ND]FreeCmd-AbsCmd5#[NF]undefined#[NF]cmd#[NF]{;;my $test;;;my @test1;;;my $akttodo;;;my $kommand ;;;my $kommand1 ;;;$test = ReadingsVal( '$SELF', 'todo', '' );;;$akttodo = ReadingsVal( '$SELF', 'todofirst', '' );;;@test1 = split(' ',$test); ;;my $farbe = $test1[$akttodo];;;my $devtoswitch = AttrVal( $name, 'DeviceToSwitch', 'no_device' );;;my $transitiontime = AttrVal( $name, 'Transitiontime', 2 );;;fhem("set $devtoswitch rgb $farbe [$SELF:Zeit]") if ('[$SELF:changergb]' eq 'timer');;;fhem("set $devtoswitch rgb $farbe $transitiontime") if ('[$SELF:changergb]' eq 'transitiontime');;;fhem("set $devtoswitch rgb $farbe") if ('[$SELF:changergb]' eq 'immediately');;;fhem("setreading $SELF aktrgb $farbe");;;;;$akttodo++;;;readingsSingleUpdate( $hash, "todofirst", "$akttodo", 0 );;;if (ReadingsVal( '$SELF', 'todoanz', '' ) < $akttodo);;{;;readingsSingleUpdate( $hash, "todofirst", 1, 0 );;;};;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]6#[NF]#[NF]0#[NF]0#[NF]10#[NF]1#[ND]MSwitch_Self-AbsCmd1#[NF]mode#[NF]no_action#[NF]RGB#[NF]#[NF]delay0#[NF]delay1#[NF]00:00:01#[NF]00:00:00#[NF][$SELF:mode] ne "Fade" OR ([$SELF:mode] eq "Fade" AND [$SELF:rgb] ne [$SELF:nextrgb] AND [$SELF:rgb] ne [$SELF:aktrgb])#[NF]#[NF]0#[NF]0#[NF]1#[NF]2#[NF]#[NF]0#[NF]0#[NF]2#[NF]1#[ND]MSwitch_Self-AbsCmd2#[NF]mode#[NF]no_action#[NF]Fade#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]11#[NF]#[NF]0#[NF]0#[NF]3#[NF]1#[ND]MSwitch_Self-AbsCmd3#[NF]exec_cmd_1#[NF]no_action#[NF]ID 1#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:01#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]11#[NF]#[NF]0#[NF]0#[NF]3#[NF]1#[ND]MSwitch_Self-AbsCmd4#[NF]aktrgb#[NF]no_action#[NF][$SELF:rgb]#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]2#[NF]2#[NF]#[NF]0#[NF]0#[NF]2#[NF]1#[ND]MSwitch_Self-AbsCmd5#[NF]exec_cmd_1#[NF]no_action#[NF]ID 1#[NF]#[NF]delay1#[NF]delay1#[NF][$SELF:Time]#[NF]00:00:00#[NF][$SELF:mode] eq "Fade"#[NF]#[NF]0#[NF]0#[NF]2#[NF]1#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]MSwitch_Self-AbsCmd6#[NF]exec_cmd_1#[NF]no_action#[NF]ID 6#[NF]#[NF]delay1#[NF]delay1#[NF][$SELF:Time]#[NF]00:00:00#[NF][$SELF:mode] eq "Spektral"#[NF]#[NF]0#[NF]0#[NF]2#[NF]6#[NF]#[NF]0#[NF]0#[NF]11#[NF]1
#S .V_Check -> V2.00
#S nextrgb -> ceb19e
#S last_activation_by -> event
#S .First_init -> done
#S rgb -> 8c577e
#S EVTPART3 -> event
#A DeviceToSwitch -> HUEDevice2
#A webCmd -> mode:changergb:Zeit:rgb:rgb FF0000:rgb 00FF00:rgb 0000FF:rgb FFFF00:rgb FFA500:rgb 8a2be2
#A userReadings -> Time:Zeit.* {#[nl]my $sec = ReadingsVal( $name, "Zeit", 0 )
#A MSwitch_Safemode -> 0
#A Transitiontime -> 1
#A setList -> Zeit:slider,1,1,60 rgb:colorpicker,rgb mode:Fade,Spektral,RGB,off aktrgb changergb:transitiontime,timer,immediately
#A MSwitch_Delete_Delays -> 1
#A MSwitch_Help -> 0
#A MSwitch_Ignore_Types -> notify allowed at watchdog doif fhem2fhem telnet FileLog readingsGroup FHEMWEB autocreate eventtypes readingsproxy svg cul
#A MSwitch_Mode -> Notify
#A MSwitch_Event_Id_Distributor -> mode:Fade=>cmd1 ID 1#[nl]mode:Spektral=>cmd1 ID 5#[nl]rgb:.*=>cmd1 ID 2#[nl]Zeit:.*=>cmd1 ID 3#[nl]mode:RGB=>cmd1 ID 4#[nl]
#A MSwitch_Include_Webcmds -> 0
#A MSwitch_Lock_Quickedit -> 1
#A stateFormat -> mode
#A MSwitch_Expert -> 1
#A userattr -> DeviceToSwitch Transitiontime
#A MSwitch_Include_Devicecmds -> 1
#A MSwitch_Extensions -> 0
#A devStateIcon -> {"off.*:FS20.off .*:FS20.on@#".ReadingsVal($name, "aktrgb", "ffffff")}
#A readingList -> Zeit rgb mode aktrgb changergb
#A MSwitch_Debug -> 0
#A MSwitch_generate_Events -> 1
#A verbose -> 1
#A MSwitch_Eventhistory -> 0
#A MSwitch_Include_MSwitchcmds -> 0
#A MSwitch_Comments -> 0

#-NEXT-
#NAME Timer
#HELP Einstellbarer Timer.Es kann eine Zeitspanne gewaehlt werden, die nach dem anschalten des Devices runterzaehlt.<br>Nach Ablauf schaltet das Device ab.<br>Bei An- oder Abschalten koennen eigene Befehle definiert werden.
#V 3.11
#VS V2.01
#S state -> off
#S Resttime -> 0
#S .Trigger_on -> no_trigger
#S Trigger_log -> off
#S .sortby -> priority
#S .Trigger_cmd_off -> no_trigger
#S Runningtime -> 30
#S Pasttime -> 30
#S .Trigger_cmd_on -> no_trigger
#S Trigger_device -> no_trigger
#S .Trigger_off -> no_trigger
#S last_activation_by -> manual
#S .Device_Affected_Details -> FreeCmd-AbsCmd1#[NF]undefined#[NF]cmd#[NF]{;;fhem ("set $SELF Resttime ".(ReadingsVal( '$SELF', 'Resttime', 0 )-1));;;fhem ("set $SELF Pasttime ".(ReadingsVal( '$SELF', 'Runningtime', 0 )- ReadingsVal( '$SELF', 'Resttime', 0 )));;;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF][$SELF:Resttime] > 0#[NF]#[NF]0#[NF]0#[NF]4#[NF]1#[NF]do not change#[NF]0#[NF]0#[NF]2#[NF]1#[ND]FreeCmd-AbsCmd2#[NF]undefined#[NF]cmd#[NF]#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]#[NF]#[NF]1#[NF]0#[NF]auzufuehrende befehle bei on ( CMD1 ) und off ( CMD2 )#[NF]0#[NF]0#[NF]1#[NF]0#[ND]MSwitch_Self-AbsCmd1#[NF]Resttime#[NF]del_delays#[NF][$SELF:Runningtime]#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]2#[NF]0#[NF]do not change#[NF]0#[NF]0#[NF]2#[NF]1#[ND]MSwitch_Self-AbsCmd2#[NF]exec_cmd_1#[NF]Resttime#[NF]ID 1#[NF]0#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]3#[NF]0#[NF]do not change#[NF]0#[NF]0#[NF]2#[NF]1#[ND]MSwitch_Self-AbsCmd3#[NF]exec_cmd_1#[NF]no_action#[NF]ID 1#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:01#[NF]00:00:00#[NF][$SELF:Resttime] > 0#[NF]#[NF]0#[NF]0#[NF]5#[NF]1#[NF]do not change#[NF]0#[NF]0#[NF]2#[NF]1#[ND]MSwitch_Self-AbsCmd4#[NF]off#[NF]no_action#[NF]#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF][$SELF:Resttime] = 0#[NF]#[NF]0#[NF]0#[NF]6#[NF]1#[NF]do not change#[NF]0#[NF]0#[NF]2#[NF]1
#S .Device_Affected -> FreeCmd-AbsCmd1,FreeCmd-AbsCmd2,MSwitch_Self-AbsCmd1,MSwitch_Self-AbsCmd2,MSwitch_Self-AbsCmd3,MSwitch_Self-AbsCmd4
#S .V_Check -> V2.01
#S last_cmd -> 6
#S .First_init -> done
#S .Device_Events -> no_trigger
#A readingList -> Runningtime Resttime Pasttime
#A MSwitch_Comments -> 1
#A MSwitch_Ignore_Types -> notify allowed at watchdog doif fhem2fhem telnet FileLog readingsGroup FHEMWEB autocreate eventtypes readingsproxy svg cul
#A setList -> Runningtime:slider,30,1,300 Resttime Pasttime
#A MSwitch_Mode -> Full
#A MSwitch_Delete_Delays -> 0
#A MSwitch_Debug -> 0
#A MSwitch_Eventhistory -> 0
#A MSwitch_Include_Devicecmds -> 1
#A stateFormat -> state#[nl]Resttime
#A MSwitch_generate_Events -> 0
#A MSwitch_Language -> DE
#A MSwitch_Help -> 0
#A MSwitch_Include_MSwitchcmds -> 0
#A MSwitch_Extensions -> 0
#A webCmd -> on:off:Runningtime
#A MSwitch_Include_Webcmds -> 0
#A MSwitch_Selftrigger_always -> 1
#A MSwitch_Lock_Quickedit -> 0
#A MSwitch_Expert -> 1
#A MSwitch_Safemode -> 1

#-NEXT-

#NAME Slowdimmer
#HELP Dimmt ein Device in einstellbaren Intervallen und Stufen.<br>Das Device kann mit:<br>set Device dimm x,y<br>angesprochen werden.<br>x - Prozent<br>y - Zeitspanne<br>Ansprechbar sind all Devices die sich mit set DEVICE pct xxx steuern lassen.
#V 3.16
#VS V2.01
#S last_cmd -> 1
#S .Trigger_cmd_on -> no_trigger
#S Trigger_device -> no_trigger
#S intervall_percent -> 5
#S EVTFULL -> HUEDevice2:pct:0
#S .sortby -> show
#S EVTPART3 -> 0
#S target_ewrartet -> 0 
#S autostop -> off
#S pct -> 0
#S startpoint -> undefiniert
#S .Trigger_time -> 
#S last_event -> pct:0
#S .V_Check -> V2.01
#S state -> on
#S EVENT -> init
#S .Trigger_cmd_off -> no_trigger
#S intervall_time -> 00:00:02
#S target_is -> 0
#S .Device_Events -> no_trigger
#S EVTPART2 -> pct
#S akt_driving -> dimming_none
#S EVTPART1 -> HUEDevice2
#S .Trigger_on -> no_trigger
#S stop -> on
#S last_activation_by -> event
#S .Trigger_condition -> "$EVENT"#[sp]=#[ti]#[sp]m/(dimm.*)|(pct.*)|(stop.*)/
#S .Device_Affected -> FreeCmd-AbsCmd1,FreeCmd-AbsCmd2,FreeCmd-AbsCmd3,FreeCmd-AbsCmd4,FreeCmd-AbsCmd5,MSwitch_Self-AbsCmd1,MSwitch_Self-AbsCmd2,MSwitch_Self-AbsCmd3
#S dimm -> 10,50,5
#S Trigger_log -> off
#S .First_init -> done
#S target_next -> 0
#S .Trigger_off -> no_trigger
#S .Device_Affected_Details -> FreeCmd-AbsCmd1#[NF]undefined#[NF]cmd#[NF]{;;my $device = "[$SELF:Trigger_device]";;;my $driving = "[$SELF:akt_driving]";;;;;;;;;Log3( $SELF, 0, "$device - $driving ");;;;;;;my $targis= ReadingsNum("$SELF","startpoint","undefiniert");;;if ($targis eq "undefiniert");;{;;$targis = ReadingsNum($device,"pct","0");;;;;};;readingsSingleUpdate( $hash, "startpoint","undefiniert", 1 );;;my $targsoll = "[$SELF:pct]";;;;;readingsSingleUpdate( $hash, "state","on", 1 );;;;;if ($targsoll eq $targis );;{;;readingsSingleUpdate( $hash, "akt_driving","dimming_none", 1 ) if $driving ne "dimming_none";;;};;readingsSingleUpdate( $hash, "target_is","$targis", 1 );;;;;my $step = "[$SELF:intervall_percent]";;;my $targ_cmd = AttrVal( "$SELF", 'setcmd', 'pct' ); ;;my $targnext = $targsoll;;;my $targerwartet = $targsoll;;;;;if ($targis < $targsoll);; {;;  $targnext = $targis+$step;;;  $targerwartet =$targnext+$step;;;  $targnext = $targsoll if $targnext > $targsoll;;;;;  readingsSingleUpdate( $hash, "akt_driving","dimming-up", 1 ) if $driving ne "dimming-up";;;;; };;elsif ($targis > $targsoll);; {;;  $targnext = $targis-$step;;;  $targerwartet =$targnext-$step;;;  $targnext = $targsoll if $targnext < $targsoll;;;;;  readingsSingleUpdate( $hash, "akt_driving","dimming-down", 1 ) if $driving ne "dimming-down";;; };;$targnext = 100 if $targnext > 100;;;$targnext = 0 if $targnext < 0;;;;;readingsSingleUpdate( $hash, "target_next","$targnext", 1 );;;readingsSingleUpdate( $hash, "target_ewrartet","$targerwartet ", 1 );;;fhem("set $device $targ_cmd $targnext") ;;;;;return;;;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]FreeCmd-AbsCmd2#[NF]undefined#[NF]cmd#[NF]{;;fhem("set $SELF del_delays");;;readingsSingleUpdate( $hash, "pct","[$SELF:EVTPART3]", 1 );;;readingsSingleUpdate( $hash, "target_next","[$SELF:EVTPART3]", 1 );;;readingsSingleUpdate( $hash, "target_is","[$SELF:EVTPART3]", 1 );;;};;#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF][$SELF:target_next] ne [$SELF:EVTPART3] AND [$SELF:autostop] eq "on"#[NF]#[NF]0#[NF]0#[NF]1#[NF]2#[NF]#[NF]0#[NF]0#[NF]4#[NF]1#[ND]FreeCmd-AbsCmd3#[NF]undefined#[NF]cmd#[NF]{;;fhem("set $SELF del_delays") ;;;readingsSingleUpdate( $hash, "pct","[$SELF:target_next]", 1 );;;#readingsSingleUpdate( $hash, "target_next","[$SELF:EVTPART3]", 1 );;;readingsSingleUpdate( $hash, "target_is","[$SELF:target_next]", 1 );;;readingsSingleUpdate( $hash, "akt_driving","dimming_none", 1 );;;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]3#[NF]#[NF]0#[NF]0#[NF]5#[NF]1#[ND]FreeCmd-AbsCmd4#[NF]undefined#[NF]cmd#[NF]{;;my $device = "[$SELF:Trigger_device]";;;fhem("set $device on") ;;;}#[NF]{;;my $device = "[$SELF:Trigger_device]";;;fhem("set $device off") ;;;}#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]FreeCmd-AbsCmd5#[NF]undefined#[NF]cmd#[NF]{;;fhem("setreading $SELF startpoint undefiniert");;;my $argument = ReadingsVal("$SELF","EVTPART3","0");;;my $startpoint=ReadingsNum($device,"pct","0");;;my $device = ReadingsVal("$SELF","Trigger_device","0");;;my $endpoint=0;;;my $ramptime=0;;;my $korrektur=0;;;;;my @argus = split(/,/,$argument );;;;;my $arranz = @argus;;;;;if ( $arranz == 2);;{;;;;$endpoint = $argus[0];;;$ramptime = $argus[1];;;};;;;if ( $arranz == 3);;{;;$endpoint = $argus[1];;;$ramptime = $argus[2];;;$startpoint = $argus[0];;;;;fhem("set $device pct ".$startpoint);;;fhem("setreading $SELF startpoint ".$startpoint);;;};;;;my $ziel = $endpoint;;;;;fhem("setreading $SELF target_next ".$startpoint);;;fhem("setreading $SELF target_ewrartet ".$startpoint);;;fhem("setreading $SELF pct ".$startpoint);;;fhem("setreading $SELF target_is ".$startpoint);;;;;if ($endpoint > $startpoint);;{;;$korrektur = $endpoint-$startpoint;;;};;;;if ($endpoint < $startpoint);;{;;$korrektur = $startpoint-$endpoint;;;};;;;my $schrittime =1;;;my $schrittpersecond = $korrektur / $ramptime;;;my $integer = int($schrittpersecond);;;my $i =0;;;my $testschritte = $schrittpersecond;;;;;while ( $integer != $testschritte);;{;;$testschritte=$testschritte*10;;;$schrittime =$schrittime *10;;;$integer = int($testschritte);;;$i++;;;last if $i>5000;;;};;;;my $timer = $schrittime/$testschritte;;;my $percent = 1;;;;;while ( $timer < 1);;{ ;;$timer=$timer*2;;;$percent=$percent*2;;;};;;;fhem("set $SELF intervall_time ".$timer);;;fhem("set $SELF intervall_percent ".$percent);;;fhem("set $SELF pct ".$ziel);;;;;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]4#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]MSwitch_Self-AbsCmd1#[NF]exec_cmd_1#[NF]no_action#[NF]ID 1#[NF]#[NF]delay2#[NF]delay1#[NF][$SELF:intervall_time]#[NF]00:00:00#[NF][$SELF:target_is] ne [$SELF:pct]#[NF]#[NF]0#[NF]0#[NF]3#[NF]1#[NF]#[NF]0#[NF]0#[NF]3#[NF]1#[ND]MSwitch_Self-AbsCmd2#[NF]wait#[NF]no_action#[NF][$SELF:intervall_time]#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF][$SELF:autostop] eq "off"#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]MSwitch_Self-AbsCmd3#[NF]wait#[NF]no_action#[NF]0.5#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF][$SELF:autostop] eq "on"#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[NF]#[NF]0#[NF]0#[NF]1#[NF]1
#S .Distributor -> MSwitch_Self:pct:.*=>cmd1 ID 1#[nl]MSwitch_Self:stop.*=>cmd1 ID 3#[nl]MSwitch_Self:dimm.*=>cmd1 ID 4#[nl]^pct:.*=>cmd1 ID 2#[nl]
#A MSwitch_Safemode -> 0
#A MSwitch_Help -> 0
#A MSwitch_Debug -> 0
#A MSwitch_Expert -> 1
#A MSwitch_Language -> DE
#A MSwitch_Delete_Delays -> 1
#A alexaName -> Slowdimmer
#A webCmd -> on:off:dimming-stop:pct:intervall_time:intervall_percent:autostop
#A MSwitch_generate_Events -> 0
#A room -> Terasse
#A devStateIcon -> {     my $state    = ReadingsVal( $name, "akt_driving", "" );     my $statepct = ReadingsVal( $name, "pct",         0 ); $statepct = 0 if  ReadingsVal( $name, "state",0 ) eq "off";      return '<div><img src="/fhem/images/default/dimup.png">'       . sprintf( " %2.2d", ReadingsNum( $name, "target_next", 0 ) )       . '</div>'       if ( $state eq "dimming-up" );     return '<div><img src="/fhem/images/default/dimdown.png">'       . sprintf( " %2.2d", ReadingsNum( $name, "target_next", 0 ) )       . '</div>'       if ( $state eq "dimming-down" );     return '<div><img src="/fhem/images/default/on.png">'       . sprintf( " %2.2d", ReadingsNum( $name, "target_next", 0 ) )       . '</div>'       if ( $statepct =~ m/(^100$)/ );     return '<div><img src="/fhem/images/default/dim56%.png">'       . sprintf( " %2.2d", ReadingsNum( $name, "target_next", 0 ) )       . '</div>'       if ( $statepct =~ m/(^[0-9]{3}|[0-9]{2}|[1-9]{1}$)/ );     return '<div><img src="/fhem/images/default/off.png">'       . sprintf( " %2.2d", ReadingsNum( $name, "target_next", 0 ) )       . '</div>'       if ( $statepct =~ m/(^00|0$)/ ); }
#A MSwitch_Extensions -> 0
#A setList -> startpoint dimm on off autostop:on,off pct:slider,0,1,100 target_is intervall_time:00:00:01,00:00:02,00:00:03,00:00:04,00:00:05,00:00:10,00:00:15,00:00:30,00:00:45,00:01:00 intervall_percent:1,2,3,4,5,6,7,8,9,10,20,30,40,50,100 tar_next target_ewrartet akt_driving stop:stop
#A readingList -> startpoint dimm autostop pct target_is intervall_time intervall_percent targ_next target_ewrartet akt_driving stop
#A MSwitch_Eventhistory -> 10
#A MSwitch_Selftrigger_always -> 1
#A MSwitch_Include_Webcmds -> 0
#A MSwitch_Include_MSwitchcmds -> 0
#A eventMap -> /stop on:dimming-stop/
#A MSwitch_Lock_Quickedit -> 1
#A MSwitch_Inforoom -> MSwitch
#A MSwitch_DeleteCMDs -> automatic
#A MSwitch_Mode -> Full
#A MSwitch_Modul_Mode -> 0
#A MSwitch_Comments -> 0
#A setcmd -> pct
#A MSwitch_Startdelay -> 10
#A MSwitch_Ignore_Types -> "TYPE=(.*):s=[ATTR:$SELF:setcmd]"
#A MSwitch_Include_Devicecmds -> 1
#A userattr -> setcmd


#-NEXT-
#NAME Pulse
#HELP Impulsgenerator
#S .change -> Pulsedevice
#S .change_info  -> info fuer angeforderte deviceaenderung
#S .info -> Es muss nur das zu steuernde Device eingestellt werden.<br>Die Sperre kann mit: deletereading DEVICE .lock geloescht werden.<br>Der Infotext kann mit deletereading DEVICE .info geloescht werden.
#V 2.93
#VS V2.01
#S .V_Check -> V2.01
#S .Trigger_cmd_on -> no_trigger
#S .Device_Affected -> MSwitch_Self-AbsCmd1,MSwitch_Self-AbsCmd2,pulsedevice-AbsCmd1,pulsedevice-AbsCmd2
#S .First_init -> done
#S .Trigger_cmd_off -> no_trigger
#S offpulse -> 00:00:01
#S onpulse -> 00:00:01
#S Trigger_log -> off
#S last_cmd -> 1
#S .Trigger_on -> no_trigger
#S .Trigger_off -> no_trigger
#S .Device_Affected_Details -> MSwitch_Self-AbsCmd1#[NF]exec_cmd_1#[NF]no_action#[NF]ID 1#[NF]#[NF]delay1#[NF]delay1#[NF][$SELF:onpulse]#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]3#[NF]1#[ND]MSwitch_Self-AbsCmd2#[NF]exec_cmd_1#[NF]no_action#[NF]#[NF]#[NF]delay1#[NF]delay1#[NF][$SELF:offpulse]#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[NF]#[NF]0#[NF]0#[NF]4#[NF]1#[ND]pulsedevice-AbsCmd1#[NF]on#[NF]off#[NF]#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[ND]pulsedevice-AbsCmd2#[NF]off#[NF]no_action#[NF]#[NF]#[NF]delay2#[NF]delay1#[NF][$SELF:onpulse]#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]2#[NF]1
#S .Device_Events -> no_trigger
#S last_activation_by -> manual
#S .sortby -> show
#S state -> off
#A MSwitch_Lock_Quickedit -> 1
#A readingList -> onpulse offpulse
#A MSwitch_Debug -> 0
#A setList -> onpulse:0.1,0.5,00:00:01,00:00:02,00:00:03,00:00:04,00:00:05 offpulse:0.1,0.5,00:00:01,00:00:02,00:00:03,00:00:04,00:00:05
#A MSwitch_Delete_Delays -> 1
#A MSwitch_Mode -> Full
#A webCmd -> on:off:onpulse:offpulse
#A MSwitch_Safemode -> 1
#A MSwitch_Include_Devicecmds -> 1
#A MSwitch_Ignore_Types -> "TYPE=MSwitch"
#A webCmdLabel -> ::ontime:offtime
#A MSwitch_Include_MSwitchcmds -> 0
#A MSwitch_Include_Webcmds -> 0
#A MSwitch_Eventhistory -> 0
#A MSwitch_Help -> 1
#A MSwitch_Extensions -> 1
#A MSwitch_Expert -> 1


#-NEXT-
#NAME Dummy_Alexa
#HELP Dieser MSwitch-Dummy ist ueber Alexa schaltbar ( on off ). Es koennen beliebige Geraete gewaehlt werden, die bei Statusaenderung des Devices geschaltet werden - die Schaltbefehle koennen anhand der jeweiligen Befehlssaetze gewaehlt werden. Das Attribut 'alexaName' muss an den gewuenschten Namen angepasst werden
#V 3.0
#VS V2.00
#V 3.11
#VS V2.01
#S .Trigger_cmd_off -> MSwitch_Self:off:
#S Trigger_log -> off
#S .V_Check -> V2.01
#S .Trigger_cmd_on -> MSwitch_Self:on:
#S .Device_Events -> MSwitch_Self:off: MSwitch_Self:on:
#S .First_init -> done
#S last_cmd -> 1
#S state -> off
#S .Trigger_off -> no_trigger
#S .Trigger_on -> no_trigger
#S .Device_Affected -> no_device
#A MSwitch_Debug -> 0
#A MSwitch_Expert -> 1
#A MSwitch_Selftrigger_always -> 1
#A MSwitch_Eventhistory -> 0
#A setList -> on off
#A alexaName -> test
#A MSwitch_Ignore_Types -> notify allowed at watchdog doif fhem2fhem telnet FileLog readingsGroup FHEMWEB autocreate eventtypes readingsproxy svg cul
#A MSwitch_Mode -> Dummy
#A MSwitch_DeleteCMDs -> nosave
#A MSwitch_Help -> 0
#A MSwitch_Language -> DE

