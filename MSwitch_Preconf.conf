#NAME Rename
#HELP Ueberwacht an MSwitch beteiligte Devices auf Namensaenderungen
#V 2.03a_Test
#VS V2.00
#S .lock -> 1
#S last_event -> RENAMED Kamin_off Kamin
#S .Trigger_on -> no_trigger
#S .Trigger_condition -> "$EVENT"#[sp]=#[ti]#[sp]m/RENAMED(#[pt]*)/
#S .Trigger_cmd_on -> .*
#S Sys_Extension -> on
#S .inc_event -> UNDEFINED Unknown CUL_TCM97001 CUL_TCM97001_Unknown
#S Trigger_device -> global
#S state -> active
#S .Device_Affected -> FreeCmd-AbsCmd1
#S Exec_cmd -> set Rename_Ctrl off
#S .Trigger_off -> no_trigger
#S action -> show_only
#S EVENT -> RENAMED Kamin_off Kamin
#S .Device_Events -> no_trigger .*
#S .First_init -> done
#S incomming -> SAVE
#S EVTPART2 -> RENAMED Kamin_off Kamin
#S Trigger_log -> off
#S EVTPART1 -> global
#S .Device_Affected_Details -> FreeCmd-AbsCmd1#[NF]undefined#[NF]cmd#[NF]{;;my $ev = ReadingsVal( "$SELF", "incomming", "no_event" );;;my @eclude = split( / /,AttrVal( '$SELF', 'exclude_from_rename', '' ));;;my ( $cmd ,$oldorgname, $neworgname ) = split( / /, $ev );;;my @found_devices = devspec2array("TYPE=MSwitch:FILTER=.Device_Affected_Details=$oldorgname.*");;;readingsSingleUpdate( $hash, "found_devices", join("#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]undefined#[NF]undefined#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]1#[NF]1
#S .V_Check -> V2.00
#S .Trigger_cmd_off -> no_trigger
#S EVTFULL -> global:RENAMED Kamin_off Kamin
#A readingList -> action
#A MSwitch_Debug -> 0
#A MSwitch_Startdelay -> 10
#A MSwitch_Include_MSwitchcmds -> 0
#A MSwitch_Eventhistory -> 0
#A webCmd -> action
#A MSwitch_Safemode -> 0
#A disable -> 0
#A setList -> action:show_only,change_automatic
#A MSwitch_Ignore_Types -> notify allowed at watchdog doif fhem2fhem telnet FileLog readingsGroup FHEMWEB autocreate eventtypes readingsproxy svg cul
#A MSwitch_Mode -> Notify
#A MSwitch_Delete_Delays -> 1
#A MSwitch_Help -> 0
#A MSwitch_Include_Webcmds -> 0
#A MSwitch_Inforoom -> MSwitch
#A MSwitch_Lock_Quickedit -> 1
#A MSwitch_Include_Devicecmds -> 1
#A userattr -> exclude_from_rename
#A MSwitch_Expert -> 0
#A MSwitch_Extensions -> 0

#-NEXT-

#NAME Farbwechsler
#HELP Farbwechsler<br>Es koennen alle Geraete angesprochen werden die sich ueber set device rgb xxx steuern lassen.<br>Die Auswahl des Zieldevices erfolgt ueber ein zu setzendes Attribut.
#V 3.02 alpha
#VS V2.00
#S Trigger_device -> MSwitch_Self
#S .Device_Affected -> FreeCmd-AbsCmd1,FreeCmd-AbsCmd2,FreeCmd-AbsCmd3,FreeCmd-AbsCmd4,FreeCmd-AbsCmd5,MSwitch_Self-AbsCmd1,MSwitch_Self-AbsCmd2,MSwitch_Self-AbsCmd3,MSwitch_Self-AbsCmd4,MSwitch_Self-AbsCmd5,MSwitch_Self-AbsCmd6
#S EVENT -> last_activation_by:event
#S Time -> 00:00:05
#S .Device_Events -> (mode:Fade[bs]mode:RGB[bs]mode:Spektral[bs]rgb:.*[bs]Zeit:.*) no_trigger
#S .Trigger_condition -> 
#S .Trigger_cmd_on -> (mode:Fade|mode:RGB|mode:Spektral|rgb:.*|Zeit:.*)
#S .lock -> 1
#S EVTPART1 -> test
#S Trigger_log -> off
#S .info -> Es muessen keine Aenderungen vorgenommen werden. Das anzusprechende Device ist unter dem Attribut DeviceToSwitch einzustellen.<br>Mehrere Devices muessen durch Komma getrennt werden.<br>Die Sperre kann mit: deletereading DEVICE .lock geloescht werden.<br>Der Infotext kann mit deletereading DEVICE .info geloescht werden.
#S .Trigger_cmd_off -> mode:off
#S EVTFULL -> test:last_activation_by:event
#S changergb -> transitiontime
#S EVTPART2 -> last_activation_by
#S last_cmd -> 1
#S Zeit -> 2
#S state -> off
#S mode -> off
#S .Trigger_time -> 
#S .Trigger_off -> no_trigger
#S .Trigger_on -> no_trigger
#S last_event -> last_activation_by:event
#S .sortby -> show
#S aktrgb -> 8c577e
#S .Device_Affected_Details -> FreeCmd-AbsCmd1#[NF]undefined#[NF]cmd#[NF]{;;my $rgb;;;my ($r, $g, $b) = (int(rand(256)), int(rand(256)), int(rand(256)));;;$rgb = sprintf("%02x%02x%02x", $r, $g, $b);;;my $aktrgb = ReadingsVal( '$SELF', 'nextrgb', 'FFFFFF' );;;fhem("setreading $SELF nextrgb $rgb ");;;fhem("setreading $SELF aktrgb $aktrgb");;;my $devtoswitch = AttrVal( $name, 'DeviceToSwitch', 'no_device' );;;my $transitiontime = AttrVal( $name, 'Transitiontime', 1 );;;;;fhem("set $devtoswitch rgb $aktrgb [$SELF:Zeit]") if ('[$SELF:changergb]' eq 'timer');;;fhem("set $devtoswitch rgb $aktrgb $transitiontime") if ('[$SELF:changergb]' eq 'transitiontime');;;fhem("set $devtoswitch rgb $aktrgb") if ('[$SELF:changergb]' eq 'immediately');;;;;};;#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF][$SELF:mode] eq "Fade"#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]FreeCmd-AbsCmd2#[NF]undefined#[NF]cmd#[NF]{;;fhem("set $SELF mode Fade");;;}#[NF]{;;fhem("set $SELF wait 2");;;fhem("set $SELF del_delays");;;fhem("set $SELF mode off");;;my $devtoswitch = AttrVal( '$SELF', 'DeviceToSwitch', 'no_device' );;;fhem("set $devtoswitch off");;;fhem("deletereading $SELF todo.*");;;fhem("deletereading $SELF waiting");;;}#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]8#[NF]1#[ND]FreeCmd-AbsCmd3#[NF]undefined#[NF]cmd#[NF]{;;my $devtoswitch = AttrVal( $name, 'DeviceToSwitch', 'no_device' );;;fhem("set $devtoswitch rgb [$SELF:rgb]");;;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]4#[NF]#[NF]0#[NF]0#[NF]4#[NF]1#[ND]FreeCmd-AbsCmd4#[NF]undefined#[NF]cmd#[NF]{;;my $change = 1;;;my $rot;;;my $gruen;;;my $blau;;;my $rgb;;;my $count;;; ;;for($count=0;$count<=255;$count=$count + $change );;{;;$gruen = sprintf ("%02x", $count);;;$rgb .= sprintf "FF${gruen}00 ";;;};;for($count=255;$count>=0;$count=$count - $change );;{;;$rot = sprintf ("%02x", $count);;;$rgb .= sprintf "${rot}FF00 ";;;};;for($count=0;$count<=255;$count=$count + $change);;{;;$blau = sprintf ("%02x", $count);;;$rgb .= sprintf "00FF${blau} ";;;};;for($count=255;$count>=0;$count=$count - $change );;{;;$gruen = sprintf ("%02x", $count);;;$rgb .= sprintf "00${gruen}FF ";;;};;for($count=0;$count<=255;$count=$count + $change );;{;;$rot = sprintf ("%02x", $count);;;$rgb .= sprintf "${rot}00FF ";;;};;;;my @a = split(" ",$rgb);;;my $anz = @a;;;$anz=$anz-1;;;fhem("setreading $SELF todo $rgb");;;fhem("setreading $SELF todoanz $anz");;;fhem("setreading $SELF todofirst 1");;;fhem("set $SELF exec_cmd_1 ID 6");;;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]5#[NF]#[NF]0#[NF]0#[NF]9#[NF]1#[ND]FreeCmd-AbsCmd5#[NF]undefined#[NF]cmd#[NF]{;;my $test;;;my @test1;;;my $akttodo;;;my $kommand ;;;my $kommand1 ;;;$test = ReadingsVal( '$SELF', 'todo', '' );;;$akttodo = ReadingsVal( '$SELF', 'todofirst', '' );;;@test1 = split(' ',$test); ;;my $farbe = $test1[$akttodo];;;my $devtoswitch = AttrVal( $name, 'DeviceToSwitch', 'no_device' );;;my $transitiontime = AttrVal( $name, 'Transitiontime', 2 );;;fhem("set $devtoswitch rgb $farbe [$SELF:Zeit]") if ('[$SELF:changergb]' eq 'timer');;;fhem("set $devtoswitch rgb $farbe $transitiontime") if ('[$SELF:changergb]' eq 'transitiontime');;;fhem("set $devtoswitch rgb $farbe") if ('[$SELF:changergb]' eq 'immediately');;;fhem("setreading $SELF aktrgb $farbe");;;;;$akttodo++;;;readingsSingleUpdate( $hash, "todofirst", "$akttodo", 0 );;;if (ReadingsVal( '$SELF', 'todoanz', '' ) < $akttodo);;{;;readingsSingleUpdate( $hash, "todofirst", 1, 0 );;;};;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]6#[NF]#[NF]0#[NF]0#[NF]10#[NF]1#[ND]MSwitch_Self-AbsCmd1#[NF]mode#[NF]no_action#[NF]RGB#[NF]#[NF]delay0#[NF]delay1#[NF]00:00:01#[NF]00:00:00#[NF][$SELF:mode] ne "Fade" OR ([$SELF:mode] eq "Fade" AND [$SELF:rgb] ne [$SELF:nextrgb] AND [$SELF:rgb] ne [$SELF:aktrgb])#[NF]#[NF]0#[NF]0#[NF]1#[NF]2#[NF]#[NF]0#[NF]0#[NF]2#[NF]1#[ND]MSwitch_Self-AbsCmd2#[NF]mode#[NF]no_action#[NF]Fade#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]11#[NF]#[NF]0#[NF]0#[NF]3#[NF]1#[ND]MSwitch_Self-AbsCmd3#[NF]exec_cmd_1#[NF]no_action#[NF]ID 1#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:01#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]11#[NF]#[NF]0#[NF]0#[NF]3#[NF]1#[ND]MSwitch_Self-AbsCmd4#[NF]aktrgb#[NF]no_action#[NF][$SELF:rgb]#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]2#[NF]2#[NF]#[NF]0#[NF]0#[NF]2#[NF]1#[ND]MSwitch_Self-AbsCmd5#[NF]exec_cmd_1#[NF]no_action#[NF]ID 1#[NF]#[NF]delay1#[NF]delay1#[NF][$SELF:Time]#[NF]00:00:00#[NF][$SELF:mode] eq "Fade"#[NF]#[NF]0#[NF]0#[NF]2#[NF]1#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]MSwitch_Self-AbsCmd6#[NF]exec_cmd_1#[NF]no_action#[NF]ID 6#[NF]#[NF]delay1#[NF]delay1#[NF][$SELF:Time]#[NF]00:00:00#[NF][$SELF:mode] eq "Spektral"#[NF]#[NF]0#[NF]0#[NF]2#[NF]6#[NF]#[NF]0#[NF]0#[NF]11#[NF]1
#S .V_Check -> V2.00
#S nextrgb -> ceb19e
#S last_activation_by -> event
#S .First_init -> done
#S rgb -> 8c577e
#S EVTPART3 -> event
#A DeviceToSwitch -> HUEDevice2
#A webCmd -> mode:changergb:Zeit:rgb:rgb FF0000:rgb 00FF00:rgb 0000FF:rgb FFFF00:rgb FFA500:rgb 8a2be2
#A userReadings -> Time:Zeit.* {#[nl]my $sec = ReadingsVal( $name, "Zeit", 0 )
#A MSwitch_Safemode -> 0
#A Transitiontime -> 1
#A setList -> Zeit:slider,1,1,60 rgb:colorpicker,rgb mode:Fade,Spektral,RGB,off aktrgb changergb:transitiontime,timer,immediately
#A MSwitch_Delete_Delays -> 1
#A MSwitch_Help -> 0
#A MSwitch_Ignore_Types -> notify allowed at watchdog doif fhem2fhem telnet FileLog readingsGroup FHEMWEB autocreate eventtypes readingsproxy svg cul
#A MSwitch_Mode -> Notify
#A MSwitch_Event_Id_Distributor -> mode:Fade=>cmd1 ID 1#[nl]mode:Spektral=>cmd1 ID 5#[nl]rgb:.*=>cmd1 ID 2#[nl]Zeit:.*=>cmd1 ID 3#[nl]mode:RGB=>cmd1 ID 4#[nl]
#A MSwitch_Include_Webcmds -> 0
#A MSwitch_Lock_Quickedit -> 1
#A stateFormat -> mode
#A MSwitch_Expert -> 1
#A userattr -> DeviceToSwitch Transitiontime
#A MSwitch_Include_Devicecmds -> 1
#A MSwitch_Extensions -> 0
#A devStateIcon -> {"off.*:FS20.off .*:FS20.on@#".ReadingsVal($name, "aktrgb", "ffffff")}
#A readingList -> Zeit rgb mode aktrgb changergb
#A MSwitch_Debug -> 0
#A MSwitch_generate_Events -> 1
#A verbose -> 1
#A MSwitch_Eventhistory -> 0
#A MSwitch_Include_MSwitchcmds -> 0
#A MSwitch_Comments -> 0

#-NEXT-
#NAME Timer
#HELP Einstellbarer Timer.Es kann eine Zeitspanne gewaehlt werden, die nach dem anschalten des Devices runterzaehlt.<br>Nach Ablauf schaltet das Device ab.<br>Bei An- oder Abschalten koennen eigene Befehle definiert werden.
#V 2.93
#VS V2.00
#S last_activation_by -> manual
#S .Trigger_cmd_on -> no_trigger
#S .Trigger_on -> no_trigger
#S Runningtime -> 30
#S .Trigger_cmd_off -> no_trigger
#S .First_init -> done
#S last_cmd -> 3
#S Resttime -> 0
#S .Device_Affected -> FreeCmd-AbsCmd1,FreeCmd-AbsCmd2,MSwitch_Self-AbsCmd1,MSwitch_Self-AbsCmd2,MSwitch_Self-AbsCmd3,MSwitch_Self-AbsCmd4
#S .Device_Events -> no_trigger
#S Trigger_log -> off
#S .V_Check -> V2.00
#S .sortby -> priority
#S state -> off
#S .Trigger_off -> no_trigger
#S Pasttime -> 3
#S .Device_Affected_Details -> FreeCmd-AbsCmd1#[NF]undefined#[NF]cmd#[NF]{;;fhem ("set $SELF Resttime ".(ReadingsVal( '$SELF', 'Resttime', 0 )-1));;;fhem ("set $SELF Pasttime ".(ReadingsVal( '$SELF', 'Runningtime', 0 )- ReadingsVal( '$SELF', 'Resttime', 0 )));;;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF][$SELF:Resttime] > 0#[NF]#[NF]0#[NF]0#[NF]4#[NF]1#[NF]do not change#[NF]0#[NF]0#[NF]1#[NF]1#[ND]FreeCmd-AbsCmd2#[NF]undefined#[NF]cmd#[NF]{Log3( "$SELF", 0, "setze Befehl fuer on");}#[NF]{Log3( "$SELF", 0, "setze Befehl fuer off");}#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[NF]Hier auszufuehrende Befehle fuer on (CMD1) und off (CMD2) eintragen. Ausgeblendete Befehlszweige nicht loeschen oder aendern.#[NF]0#[NF]0#[NF]1#[NF]0#[ND]MSwitch_Self-AbsCmd1#[NF]Resttime#[NF]del_delays#[NF][$SELF:Runningtime]#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]2#[NF]0#[NF]do not change#[NF]0#[NF]0#[NF]1#[NF]1#[ND]MSwitch_Self-AbsCmd2#[NF]exec_cmd_1#[NF]Resttime#[NF]ID 1#[NF]0#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]3#[NF]0#[NF]do not change#[NF]0#[NF]0#[NF]1#[NF]1#[ND]MSwitch_Self-AbsCmd3#[NF]exec_cmd_1#[NF]no_action#[NF]ID 1#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:01#[NF]00:00:00#[NF][$SELF:Resttime] > 0#[NF]#[NF]0#[NF]0#[NF]5#[NF]1#[NF]do not change#[NF]0#[NF]0#[NF]1#[NF]1#[ND]MSwitch_Self-AbsCmd4#[NF]off#[NF]no_action#[NF]#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF][$SELF:Resttime] = 0#[NF]#[NF]0#[NF]0#[NF]6#[NF]1#[NF]do not change#[NF]0#[NF]0#[NF]1#[NF]1
#A MSwitch_Delete_Delays -> 0
#A MSwitch_Include_Webcmds -> 0
#A MSwitch_Extensions -> 0
#A MSwitch_Comments -> 1
#A MSwitch_Include_Devicecmds -> 1
#A stateFormat -> state#[nl]Resttime
#A setList -> Runningtime:slider,1,1,3600 Resttime Pasttime
#A MSwitch_Help -> 0
#A MSwitch_Mode -> Full
#A readingList -> Runningtime Resttime Pasttime
#A webCmd -> on:off:Runningtime
#A MSwitch_Lock_Quickedit -> 1
#A MSwitch_Ignore_Types -> notify allowed at watchdog doif fhem2fhem telnet FileLog readingsGroup FHEMWEB autocreate eventtypes readingsproxy svg cul
#A MSwitch_generate_Events -> 0
#A MSwitch_Eventhistory -> 0
#A MSwitch_Expert -> 1
#A MSwitch_Safemode -> 1
#A MSwitch_Include_MSwitchcmds -> 0
#A MSwitch_Debug -> 0

#-NEXT-
#NAME Slowdimmer
#HELP Dimmt ein Device in einstellbaren Intervallen und Stufen.<br>Das Device kann mit:<br>set Device dimm x,y<br>angesprochen werden.<br>x - Prozent<br>y - Zeitspanne<br>Ansprchbar sind all Devices die sich mit set DEVICE pct xxx steuern lassen.
#V 3.02 alpha
#VS V2.00
#S Trigger_device -> no_trigger
#S pct -> 0
#S .Device_Affected -> FreeCmd-AbsCmd1,FreeCmd-AbsCmd2,FreeCmd-AbsCmd3,FreeCmd-AbsCmd4,FreeCmd-AbsCmd5,MSwitch_Self-AbsCmd1,MSwitch_Self-AbsCmd2,MSwitch_Self-AbsCmd3
#S EVENT -> pct:0
#S .Device_Events -> no_trigger .*
#S .Trigger_condition -> "$EVENT"#[sp]=#[ti]#[sp]m/(dimm#[pt]*)|(pct#[pt]*)|(stop#[pt]*)/
#S .Trigger_cmd_on -> .*
#S target_next -> 0
#S EVTPART1 -> HUEDevice1
#S Trigger_log -> off
#S .Trigger_cmd_off -> no_trigger
#S EVTFULL -> HUEDevice1:pct:0
#S intervall_time -> 00:00:05
#S EVTPART2 -> pct
#S last_cmd -> 1
#S state -> on
#S target_is -> 0
#S .Trigger_time -> 
#S akt_driving -> dimming_none
#S .Trigger_off -> no_trigger
#S stop -> on
#S last_event -> pct:0
#S .Trigger_on -> no_trigger
#S .sortby -> show
#S target_ewrartet -> 0 
#S .Device_Affected_Details -> FreeCmd-AbsCmd1#[NF]undefined#[NF]cmd#[NF]{;;;;my $device = "[$SELF:Trigger_device]";;;my $driving = "[$SELF:akt_driving]";;;my $targis = ReadingsNum($device,"pct","0"); ;;my $targsoll = "[$SELF:pct]";;;;;;;readingsSingleUpdate( $hash, "state","on", 1 );;;;;if ($targsoll eq $targis );;{;;readingsSingleUpdate( $hash, "akt_driving","dimming_none", 1 ) if $driving ne "dimming_none";;;};;;;;;readingsSingleUpdate( $hash, "target_is","$targis", 1 );;;;;;;my $step = "[$SELF:intervall_percent]";;;my $targ_cmd = AttrVal( "$SELF", 'setcmd', 'pct' ); ;;my $targnext = $targsoll;;;my $targerwartet = $targsoll;;;;;if ($targis < $targsoll);; {;;  $targnext = $targis+$step;;;  $targerwartet =$targnext+$step;;;  $targnext = $targsoll if $targnext > $targsoll;;;;;  readingsSingleUpdate( $hash, "akt_driving","dimming-up", 1 ) if $driving ne "dimming-up";;;;; };;elsif ($targis > $targsoll);; {;;  $targnext = $targis-$step;;;  $targerwartet =$targnext-$step;;;  $targnext = $targsoll if $targnext < $targsoll;;;;;  readingsSingleUpdate( $hash, "akt_driving","dimming-down", 1 ) if $driving ne "dimming-down";;; };;$targnext = 100 if $targnext > 100;;;$targnext = 0 if $targnext < 0;;;;;readingsSingleUpdate( $hash, "target_next","$targnext", 1 );;;readingsSingleUpdate( $hash, "target_ewrartet","$targerwartet ", 1 );;;fhem("set $device $targ_cmd $targnext") ;;;;;Log3( "test", 5, "set $device $targ_cmd $targnext" );;;Log3( "test", 5, "------------------" );;;;;return;;;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]FreeCmd-AbsCmd2#[NF]undefined#[NF]cmd#[NF]{;;fhem("set $SELF del_delays");;;readingsSingleUpdate( $hash, "pct","[$SELF:EVTPART3]", 1 );;;readingsSingleUpdate( $hash, "target_next","[$SELF:EVTPART3]", 1 );;;readingsSingleUpdate( $hash, "target_is","[$SELF:EVTPART3]", 1 );;;};;#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF][$SELF:target_next] ne [$SELF:EVTPART3] AND [$SELF:autostop] eq "on"#[NF]#[NF]0#[NF]0#[NF]1#[NF]2#[NF]#[NF]0#[NF]0#[NF]4#[NF]1#[ND]FreeCmd-AbsCmd3#[NF]undefined#[NF]cmd#[NF]{;;fhem("set $SELF del_delays") ;;;readingsSingleUpdate( $hash, "pct","[$SELF:target_next]", 1 );;;#readingsSingleUpdate( $hash, "target_next","[$SELF:EVTPART3]", 1 );;;readingsSingleUpdate( $hash, "target_is","[$SELF:target_next]", 1 );;;readingsSingleUpdate( $hash, "akt_driving","dimming_none", 1 );;;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]3#[NF]#[NF]0#[NF]0#[NF]5#[NF]1#[ND]FreeCmd-AbsCmd4#[NF]undefined#[NF]cmd#[NF]{;;my $device = "[$SELF:Trigger_device]";;;fhem("set $device on") ;;;}#[NF]{;;my $device = "[$SELF:Trigger_device]";;;fhem("set $device off") ;;;}#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]FreeCmd-AbsCmd5#[NF]undefined#[NF]cmd#[NF]{;;my @argus;;;my $device = ReadingsVal("$SELF","Trigger_device","0");;;#Log3( "test", 0, "$device" );;;my $targis = ReadingsNum($device,"pct","0"); ;;#Log3( "test", 0, "targis: $targis" );;;my $korrektur=0;;;#Log3( "test", 0, "[$SELF:EVTPART3]" );;;my $argument = ReadingsVal("$SELF","EVTPART3","0");;;@argus = split(/,/,$argument );;;#Log3( "test", 0, "$argus[0]" );;;#Log3( "test", 0, "$argus[1]" );;;my $ziel = $argus[0];;;;;fhem("setreading $SELF target_next ".$targis);;;fhem("setreading $SELF target_ewrartet ".$targis);;;fhem("setreading $SELF pct ".$targis);;;fhem("setreading $SELF target_is ".$targis);;;;;if ($argus[0] > $targis);;{;;$korrektur = $argus[0]-$targis;;;};;if ($argus[0] < $targis);;{;;$korrektur = $targis-$argus[0];;;};;;;#Log3( "test", 0, "korrektur = $korrektur" );;;;;my $schrittime =1;;;my $schrittpersecond = $korrektur / $argus[1];;;;;#Log3( "test", 0, "schritte pro sekunde  = $schrittpersecond" );;;;;my $integer = int($schrittpersecond);;;#Log3( "test", 0, "integer schritte pro sekunde  = $integer" );;;;;my $i =0;;;;;my $testschritte = $schrittpersecond;;;;;while ( $integer != $testschritte);;{;;$testschritte=$testschritte*10;;;$schrittime =$schrittime *10;;;$integer = int($testschritte);;;Log3( "test", 0, "i=$i:integer schritte pro sekunde=$integer:schritte pro sekunde=$testschritte" );;;$i++;;;last if $i>5000;;;};;;;#Log3( "test", 0, "ergebniss: $testschritte alle $schrittime sekunden " );;;;;my $timer = $schrittime/$testschritte;;;#Log3( "test", 0, "änderung 1% alle $timer sekunden " );;;# wenn kleiner 1 pro sekunde;;;;my $percent = 1;;;while ( $timer < 1);;{ ;;$timer=$timer*2;;;$percent=$percent*2;;;};;;;#Log3( "test", 0, "änderung $percent % alle $timer sekunden " );;;fhem("set $SELF intervall_time ".$timer);;;fhem("set $SELF intervall_percent ".$percent);;;#Log3( "test", 0, "Ziel $ziel" );;;fhem("set $SELF pct ".$ziel);;;}#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]4#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]MSwitch_Self-AbsCmd1#[NF]exec_cmd_1#[NF]no_action#[NF]ID 1#[NF]#[NF]delay2#[NF]delay1#[NF][$SELF:intervall_time]#[NF]00:00:00#[NF][$SELF:target_is] ne [$SELF:pct]#[NF]#[NF]0#[NF]0#[NF]3#[NF]1#[NF]#[NF]0#[NF]0#[NF]3#[NF]1#[ND]MSwitch_Self-AbsCmd2#[NF]wait#[NF]no_action#[NF][$SELF:intervall_time]#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF][$SELF:autostop] eq "off"#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[ND]MSwitch_Self-AbsCmd3#[NF]wait#[NF]no_action#[NF]0.5#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF][$SELF:autostop] eq "on"#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[NF]#[NF]0#[NF]0#[NF]1#[NF]1
#S .V_Check -> V2.00
#S intervall_percent -> 2
#S .First_init -> done
#S last_activation_by -> event
#S dimm -> 0,60
#S autostop -> on
#S EVTPART3 -> 0
#A setcmd -> pct
#A MSwitch_generate_Events -> 0
#A eventMap -> /stop on:dimming-stop/
#A MSwitch_Selftrigger_always -> 1
#A readingList -> dimm autostop pct target_is intervall_time intervall_percent targ_next target_ewrartet akt_driving stop
#A devStateIcon -> {     my $state    = ReadingsVal( $name, "akt_driving", "" );     my $statepct = ReadingsVal( $name, "pct",         0 ); $statepct = 0 if  ReadingsVal( $name, "state",0 ) eq "off";      return '<div><img src="/fhem/images/default/dimup.png">'       . sprintf( " %2.2d", ReadingsNum( $name, "target_next", 0 ) )       . '</div>'       if ( $state eq "dimming-up" );     return '<div><img src="/fhem/images/default/dimdown.png">'       . sprintf( " %2.2d", ReadingsNum( $name, "target_next", 0 ) )       . '</div>'       if ( $state eq "dimming-down" );     return '<div><img src="/fhem/images/default/on.png">'       . sprintf( " %2.2d", ReadingsNum( $name, "target_next", 0 ) )       . '</div>'       if ( $statepct =~ m/(^100$)/ );     return '<div><img src="/fhem/images/default/dim56%.png">'       . sprintf( " %2.2d", ReadingsNum( $name, "target_next", 0 ) )       . '</div>'       if ( $statepct =~ m/(^[0-9]{3}|[0-9]{2}|[1-9]{1}$)/ );     return '<div><img src="/fhem/images/default/off.png">'       . sprintf( " %2.2d", ReadingsNum( $name, "target_next", 0 ) )       . '</div>'       if ( $statepct =~ m/(^00|0$)/ ); }
#A MSwitch_Debug -> 0
#A room -> 01_Test->Slowdimmer,alexa
#A MSwitch_Include_MSwitchcmds -> 0
#A MSwitch_Comments -> 0
#A MSwitch_Eventhistory -> 10
#A MSwitch_Startdelay -> 10
#A alexaName -> Slowdimmer
#A setList -> dimm on off autostop:on,off pct:slider,0,1,100 target_is intervall_time:00:00:01,00:00:02,00:00:03,00:00:04,00:00:05,00:00:10,00:00:15,00:00:30,00:00:45,00:01:00 intervall_percent:1,2,3,4,5,6,7,8,9,10,20,30,40,50,100 tar_next target_ewrartet akt_driving stop:stop
#A MSwitch_Mode -> Notify
#A MSwitch_Ignore_Types -> "TYPE=(.*):s=[ATTR:$SELF:setcmd]"
#A MSwitch_Help -> 0
#A MSwitch_Delete_Delays -> 1
#A webCmd -> on:off:dimming-stop:pct:intervall_time:intervall_percent:autostop
#A MSwitch_DeleteCMDs -> automatic
#A userattr -> setcmd
#A MSwitch_Include_Devicecmds -> 1
#A MSwitch_Expert -> 1
#A MSwitch_Extensions -> 0
#A MSwitch_Include_Webcmds -> 0
#A MSwitch_Event_Id_Distributor -> MSwitch_Self:pct:.*=>cmd1 ID 1#[nl]MSwitch_Self:stop.*=>cmd1 ID 3#[nl]MSwitch_Self:dimm.*=>cmd1 ID 4#[nl]^pct:.*=>cmd1 ID 2#[nl]
#A MSwitch_Language -> DE
#A MSwitch_Lock_Quickedit -> 1

#-NEXT-
#NAME Pulse
#HELP Impulsgenerator
#S .change -> Pulsedevice
#S .change_info  -> info für angeforderte deviceänderung
#S .info -> Es muss nur das zu steuernde Device eingestellt werden.<br>Die Sperre kann mit: deletereading DEVICE .lock geloescht werden.<br>Der Infotext kann mit deletereading DEVICE .info geloescht werden.
#V 2.93
#VS V2.00
#S .V_Check -> V2.00
#S .Trigger_cmd_on -> no_trigger
#S .Device_Affected -> MSwitch_Self-AbsCmd1,MSwitch_Self-AbsCmd2,pulsedevice-AbsCmd1,pulsedevice-AbsCmd2
#S .First_init -> done
#S .Trigger_cmd_off -> no_trigger
#S offpulse -> 00:00:01
#S onpulse -> 00:00:01
#S Trigger_log -> off
#S last_cmd -> 1
#S .Trigger_on -> no_trigger
#S .Trigger_off -> no_trigger
#S .Device_Affected_Details -> MSwitch_Self-AbsCmd1#[NF]exec_cmd_1#[NF]no_action#[NF]ID 1#[NF]#[NF]delay1#[NF]delay1#[NF][$SELF:onpulse]#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]3#[NF]1#[ND]MSwitch_Self-AbsCmd2#[NF]exec_cmd_1#[NF]no_action#[NF]#[NF]#[NF]delay1#[NF]delay1#[NF][$SELF:offpulse]#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]1#[NF]#[NF]0#[NF]0#[NF]4#[NF]1#[ND]pulsedevice-AbsCmd1#[NF]on#[NF]off#[NF]#[NF]#[NF]delay1#[NF]delay1#[NF]00:00:00#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[ND]pulsedevice-AbsCmd2#[NF]off#[NF]no_action#[NF]#[NF]#[NF]delay2#[NF]delay1#[NF][$SELF:onpulse]#[NF]00:00:00#[NF]#[NF]#[NF]0#[NF]0#[NF]1#[NF]0#[NF]#[NF]0#[NF]0#[NF]2#[NF]1
#S .Device_Events -> no_trigger
#S last_activation_by -> manual
#S .sortby -> show
#S state -> off
#A MSwitch_Lock_Quickedit -> 1
#A readingList -> onpulse offpulse
#A MSwitch_Debug -> 0
#A setList -> onpulse:0.1,0.5,00:00:01,00:00:02,00:00:03,00:00:04,00:00:05 offpulse:0.1,0.5,00:00:01,00:00:02,00:00:03,00:00:04,00:00:05
#A MSwitch_Delete_Delays -> 1
#A MSwitch_Mode -> Full
#A webCmd -> on:off:onpulse:offpulse
#A MSwitch_Safemode -> 1
#A MSwitch_Include_Devicecmds -> 1
#A MSwitch_Ignore_Types -> "TYPE=MSwitch"
#A webCmdLabel -> ::ontime:offtime
#A MSwitch_Include_MSwitchcmds -> 0
#A MSwitch_Include_Webcmds -> 0
#A MSwitch_Eventhistory -> 0
#A MSwitch_Help -> 1
#A MSwitch_Extensions -> 1
#A MSwitch_Expert -> 1

